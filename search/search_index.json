{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Rustus is a TUS protocol implementation that helps you handle file uploads. This project has many features that make it easy to integrate with your application. Installation You can install rustus in four different ways. From source To build it from source rust must be installed. Preferred version is 1.59.0. git clone https://github.com/s3rius/rustus.git cd rustus cargo install --path . --features = all,metrics Also, you can speedup build by disabling some features. Available features: amqp_notifier - adds AMQP protocol support for notifying about upload status; db_info_storage - adds support for storing information about upload in different databases ( Postgres , MySQL , SQLite ); http_notifier - adds support for notifying about upload status via HTTP protocol; redis_info_storage - adds support for storing information about upload in Redis database; hashers - adds support for checksum verification; metrics - adds rustus specific metrics to prometheus endpoint; all - enables all rustus features except metrics . All precompiled binaries have all features enabled. With cargo If you have cargo installed, it might be easier to install it directly from crates.io. cargo install rustus --features = all Binaries All precompiled binaries available on Github releases page. You can download binaries from here , unpack it and run. ./rustus Make sure you download right version for your CPU architecture and OS. Using Docker One of the most simple ways to run rustus is Docker . Rustus has two containers for each version. 1. Debian based image 2. Alpine based image Alpine based images are more lightweight than Debian To run Rustus with Docker you just need to run this command docker run --rm -p \"1081:1081\" -d s3rius/rustus --log-level \"DEBUG\" More information about Rustus docker images you can find on Docker hub page .","title":"Welcome page"},{"location":"#installation","text":"You can install rustus in four different ways.","title":"Installation"},{"location":"#from-source","text":"To build it from source rust must be installed. Preferred version is 1.59.0. git clone https://github.com/s3rius/rustus.git cd rustus cargo install --path . --features = all,metrics Also, you can speedup build by disabling some features. Available features: amqp_notifier - adds AMQP protocol support for notifying about upload status; db_info_storage - adds support for storing information about upload in different databases ( Postgres , MySQL , SQLite ); http_notifier - adds support for notifying about upload status via HTTP protocol; redis_info_storage - adds support for storing information about upload in Redis database; hashers - adds support for checksum verification; metrics - adds rustus specific metrics to prometheus endpoint; all - enables all rustus features except metrics . All precompiled binaries have all features enabled.","title":"From source"},{"location":"#with-cargo","text":"If you have cargo installed, it might be easier to install it directly from crates.io. cargo install rustus --features = all","title":"With cargo"},{"location":"#binaries","text":"All precompiled binaries available on Github releases page. You can download binaries from here , unpack it and run. ./rustus Make sure you download right version for your CPU architecture and OS.","title":"Binaries"},{"location":"#using-docker","text":"One of the most simple ways to run rustus is Docker . Rustus has two containers for each version. 1. Debian based image 2. Alpine based image Alpine based images are more lightweight than Debian To run Rustus with Docker you just need to run this command docker run --rm -p \"1081:1081\" -d s3rius/rustus --log-level \"DEBUG\" More information about Rustus docker images you can find on Docker hub page .","title":"Using Docker"},{"location":"configuration/","text":"Rustus is highly configurable. You can adjust it with CLI or you can use environment variables. Info Information about hooks you can find on Hooks page . Configuring server We use actix to run server. You can configure on which host and port rustus is listening. Also you can configure number of actix workers that handle connections. --max-body-size is the max number of bytes that users can send in request body. --url is a base URL for all tus requests. --workers by default is equal to number of physical CPU cores. Edit it carefully. --cors is a list of allowed hosts with wildcards separated by commas. By default all hosts are allowed. You can define which hosts are allowed for your particular application. For example if you add --cors \"*.staging.domain,*.prod.domain\" , it allows all origins like my.staging.domain or my.prod.domain , but it will refuse to serve other origins. CLI ENV rustus --host \"0.0.0.0\" \\ --port 1081 \\ --workers 8 \\ --max-body-size 1000000 \\ --url \"/files\" \\ --log-level \"INFO\" --cors \"my.*.domain.com,your.*.domain.com\" export RUSTUS_SERVER_HOST = \"0.0.0.0\" export RUSTUS_SERVER_PORT = \"1081\" export RUSTUS_SERVER_WORKERS = \"8\" export RUSTUS_MAX_BODY_SIZE = \"1000000\" export RUSTUS_URL = \"/files\" export RUSTUS_LOG_LEVEL = \"INFO\" export RUSTUS_CORS = \"my.*.domain.com,your.*.domain.com\" rustus Configuring data storage Info Currently only file storage is available, so if you pass to --storage parameter other than file-storage you will get an error. Available parameters: --storage - type of data storage to be used; --data-dir - path to the directory where all files are stored; --dir-structure - pattern of a directory structure inside data dir; --force-fsync - calls fsync system call after every write to disk. `` You can use variables within the pattern. Available variables: {year} - current year; {month} - current month number from 1 to 12; {day} - current day number from 1 to 31; {hour} - hour number from 0 to 23; {minute} - minute number from 0 to 59; For example if you use files/{year}/{month}/{day} as your dir-structure, rustus stores files like: $ tree data data \u2514\u2500\u2500 files \u2514\u2500\u2500 2022 \u2514\u2500\u2500 1 \u2514\u2500\u2500 8 \u251c\u2500\u2500 0bd911d4054d41c6a3ad54be67ee3e66 \u2514\u2500\u2500 5bc9c62384494c439e2a064b82a39cc6 CLI ENV rustus --force-fsync \"yes\" \\ --storage \"file-storage\" \\ --data-dir \"./data/\" \\ --dir-structure \"{year}/{month}/{day}\" export RUSTUS_STORAGE = \"file-storage\" export RUSTUS_DATA_DIR = \"./data/\" export RUSTUS_DIR_STRUCTURE = \"{year}/{month}/{day}\" export RUSTUS_FORCE_FSYNC = \"yes\" rustus Configuring info storage Info storages are used to store information about file uploads. These storages must be persistent, because every time chunk is uploaded rustus updates information about upload. And when someone wants to download file, information about it requested from storage to get actual path of an upload. Available info storages: file-info-storage - stores information in files on disk; redis-info-storage - information is stored in Redis; db-info-storage - information is stored in database; File info storage file info storage stores information in files on disk. It's default info storage. Every download has it's own associated file. All .info files stored in flat structure so it's the least preferable way of storing information about uploads. But if you don't plan to have many uploads, it may fit well. --info-dir - directory where all .info file will be stored (default is ./data ). CLI ENV rustus --info-storage \"file-info-storage\" \\ --info-dir \"./data\" export RUSTUS_INFO_STORAGE = \"file-info-storage\" export RUSTUS_INFO_DIR = \"./data\" rustus Redis info storage Redis db is a good way to store information. Note If you're using Redis as a cluster you must provide connection string for master Redis server. Since rustus need to have latest information and it writes a lot. --info-db-dsn - connection string for your Redis database. It's required if redis-info-storage is chosen. CLI ENV rustus --info-storage \"redis-info-storage\" \\ --info-db-dsn \"redis://localhost/0\" export RUSTUS_INFO_STORAGE = \"redis-info-storage\" export RUSTUS_INFO_DB_DSN = \"redis://localhost\" rustus DB info storage Rustus can store information about upload in a database. It's a good and reliable option. But Rustus can't work with replicas, since it requires the most recent information about uploads. You can use postgresql , mysql or even sqlite schemas to connect to database. --info-db-dsn - connection string for your database. CLI ENV rustus --info-storage \"db-info-storage\" \\ --info-db-dsn \"postgresql://user:password@localhost/db\" export RUSTUS_INFO_STORAGE = \"redis-info-storage\" export RUSTUS_INFO_DB_DSN = \"postgresql://user:password@localhost/db\" rustus Configuring TUS Since TUS protocol offers extensibility you can turn off some protocol extensions. Available extensions: getting - Rustus specific extension that helps you download uploaded files with get request; creation - helps you to create files (It's like a core feature you better have this enabled); termination - allows you to delete uploads with DELETE request; creation-with-upload - allows you to write first bytes of a file while creating; creation-defer-length - allows you to create file without specifying file length; concatenation - allows you to concatenate finished partial uploads. checksum - allows you to verify checksum of every batch. You can read more about extensions on official web-site . --tus-extensions - a list of enabled extensions. --remove-parts - remove parts files after successful concatenation (disabled by default). By default all extensions are enabled. CLI ENV rustus --remove-parts \"yes\" \\ --tus-extensions \"getting,creation,termination,creation-with-upload,creation-defer-length,concatenation,checksum\" export RUSTUS_TUS_EXTENSIONS = \"getting,creation,termination,creation-with-upload,creation-defer-length,concatenation,checksum\" export RUSTUS_REMOVE_PARTS = \"yes\" rustus","title":"Configuration"},{"location":"configuration/#configuring-server","text":"We use actix to run server. You can configure on which host and port rustus is listening. Also you can configure number of actix workers that handle connections. --max-body-size is the max number of bytes that users can send in request body. --url is a base URL for all tus requests. --workers by default is equal to number of physical CPU cores. Edit it carefully. --cors is a list of allowed hosts with wildcards separated by commas. By default all hosts are allowed. You can define which hosts are allowed for your particular application. For example if you add --cors \"*.staging.domain,*.prod.domain\" , it allows all origins like my.staging.domain or my.prod.domain , but it will refuse to serve other origins. CLI ENV rustus --host \"0.0.0.0\" \\ --port 1081 \\ --workers 8 \\ --max-body-size 1000000 \\ --url \"/files\" \\ --log-level \"INFO\" --cors \"my.*.domain.com,your.*.domain.com\" export RUSTUS_SERVER_HOST = \"0.0.0.0\" export RUSTUS_SERVER_PORT = \"1081\" export RUSTUS_SERVER_WORKERS = \"8\" export RUSTUS_MAX_BODY_SIZE = \"1000000\" export RUSTUS_URL = \"/files\" export RUSTUS_LOG_LEVEL = \"INFO\" export RUSTUS_CORS = \"my.*.domain.com,your.*.domain.com\" rustus","title":"Configuring server"},{"location":"configuration/#configuring-data-storage","text":"Info Currently only file storage is available, so if you pass to --storage parameter other than file-storage you will get an error. Available parameters: --storage - type of data storage to be used; --data-dir - path to the directory where all files are stored; --dir-structure - pattern of a directory structure inside data dir; --force-fsync - calls fsync system call after every write to disk. `` You can use variables within the pattern. Available variables: {year} - current year; {month} - current month number from 1 to 12; {day} - current day number from 1 to 31; {hour} - hour number from 0 to 23; {minute} - minute number from 0 to 59; For example if you use files/{year}/{month}/{day} as your dir-structure, rustus stores files like: $ tree data data \u2514\u2500\u2500 files \u2514\u2500\u2500 2022 \u2514\u2500\u2500 1 \u2514\u2500\u2500 8 \u251c\u2500\u2500 0bd911d4054d41c6a3ad54be67ee3e66 \u2514\u2500\u2500 5bc9c62384494c439e2a064b82a39cc6 CLI ENV rustus --force-fsync \"yes\" \\ --storage \"file-storage\" \\ --data-dir \"./data/\" \\ --dir-structure \"{year}/{month}/{day}\" export RUSTUS_STORAGE = \"file-storage\" export RUSTUS_DATA_DIR = \"./data/\" export RUSTUS_DIR_STRUCTURE = \"{year}/{month}/{day}\" export RUSTUS_FORCE_FSYNC = \"yes\" rustus","title":"Configuring data storage"},{"location":"configuration/#configuring-info-storage","text":"Info storages are used to store information about file uploads. These storages must be persistent, because every time chunk is uploaded rustus updates information about upload. And when someone wants to download file, information about it requested from storage to get actual path of an upload. Available info storages: file-info-storage - stores information in files on disk; redis-info-storage - information is stored in Redis; db-info-storage - information is stored in database;","title":"Configuring info storage"},{"location":"configuration/#file-info-storage","text":"file info storage stores information in files on disk. It's default info storage. Every download has it's own associated file. All .info files stored in flat structure so it's the least preferable way of storing information about uploads. But if you don't plan to have many uploads, it may fit well. --info-dir - directory where all .info file will be stored (default is ./data ). CLI ENV rustus --info-storage \"file-info-storage\" \\ --info-dir \"./data\" export RUSTUS_INFO_STORAGE = \"file-info-storage\" export RUSTUS_INFO_DIR = \"./data\" rustus","title":"File info storage"},{"location":"configuration/#redis-info-storage","text":"Redis db is a good way to store information. Note If you're using Redis as a cluster you must provide connection string for master Redis server. Since rustus need to have latest information and it writes a lot. --info-db-dsn - connection string for your Redis database. It's required if redis-info-storage is chosen. CLI ENV rustus --info-storage \"redis-info-storage\" \\ --info-db-dsn \"redis://localhost/0\" export RUSTUS_INFO_STORAGE = \"redis-info-storage\" export RUSTUS_INFO_DB_DSN = \"redis://localhost\" rustus","title":"Redis info storage"},{"location":"configuration/#db-info-storage","text":"Rustus can store information about upload in a database. It's a good and reliable option. But Rustus can't work with replicas, since it requires the most recent information about uploads. You can use postgresql , mysql or even sqlite schemas to connect to database. --info-db-dsn - connection string for your database. CLI ENV rustus --info-storage \"db-info-storage\" \\ --info-db-dsn \"postgresql://user:password@localhost/db\" export RUSTUS_INFO_STORAGE = \"redis-info-storage\" export RUSTUS_INFO_DB_DSN = \"postgresql://user:password@localhost/db\" rustus","title":"DB info storage"},{"location":"configuration/#configuring-tus","text":"Since TUS protocol offers extensibility you can turn off some protocol extensions. Available extensions: getting - Rustus specific extension that helps you download uploaded files with get request; creation - helps you to create files (It's like a core feature you better have this enabled); termination - allows you to delete uploads with DELETE request; creation-with-upload - allows you to write first bytes of a file while creating; creation-defer-length - allows you to create file without specifying file length; concatenation - allows you to concatenate finished partial uploads. checksum - allows you to verify checksum of every batch. You can read more about extensions on official web-site . --tus-extensions - a list of enabled extensions. --remove-parts - remove parts files after successful concatenation (disabled by default). By default all extensions are enabled. CLI ENV rustus --remove-parts \"yes\" \\ --tus-extensions \"getting,creation,termination,creation-with-upload,creation-defer-length,concatenation,checksum\" export RUSTUS_TUS_EXTENSIONS = \"getting,creation,termination,creation-with-upload,creation-defer-length,concatenation,checksum\" export RUSTUS_REMOVE_PARTS = \"yes\" rustus","title":"Configuring TUS"},{"location":"deploy/","text":"Deployment Deploying an application is always a challenge. Rustus was made to make deployment as easy as possible. Since Rustus works with files you have to be careful while scaling it. All rustus instances must have access to the same data and info storages. Info If you want to track you rustus instances with prometheus you can always get metrics at /metrics endpoint. Docker compose docker-compose.yml # This is super simple configuration version : \"3.7\" services : rustus : image : s3rius/rustus volumes : # Volume mounted to default data directory # So it's available across multiple containers. - rustus_data_volume:/app/data volumes : rustus_data_volume : After running docker compose up you will see rustus startup logs. If you want to deploy multiple rustus instances you can simply use config as this one: docker-compose.yml version : \"3.7\" services : proxy : image : jwilder/nginx-proxy:alpine container_name : proxy # Actual proxy ports. ports : - 8080:80 volumes : # This thing helps to locate containers # within this composition to generate nginx config. - /var/run/docker.sock:/tmp/docker.sock:ro rustus : image : s3rius/rustus ports : # Ports definition # To generate correct nginx config. - 1081 volumes : # Volume mounted to default data directory # So it's available across multiple containers. - rustus_data_volume:/app/data environment : # Idk why but without this variable # load balancing with jwilder/nginx-proxy doesn't work. VIRTUAL_HOST : localhost volumes : rustus_data_volume : # This is named volume The main idea is that traffic that comes into nginx-proxy is routed in one of multiple rustus containers. Here I used jwilder/nginx-proxy but you can use other reverse-proxies such as Nginx proxy , Traefik or Envoy proxy . Now you can run multiple rustus instances like this. docker compose up --scale rustus = 3 After that you can upload files to http://localhost:8080/files Kubernetes Configuration for Kubernetes is almost the same as for Docker. But the most preferable way is an official helm chart. Load balancing is done by Kubernetes, so you just have to create a volume to mount data and info directories. Helm You can install rustus by running this set of commands: helm repo add \"rustus\" \"https://s3rius.github.io/rustus/helm_releases\" helm repo update helm install \"rustus\" \"rustus/rustus\" Configuration Since default deployment may not fit you. You can adjust it to satisfy your needs. You can do it easily with helm. At first you need to save default values on disk. # You can download basic configuration by running helm show values \"rustus/rustus\" > values.yml Warning For production use you must provide and mount PersistentVolumeClaim in order to scale rustus. This helm chart has only one replica by default. You can read more about configuration below. After you done editing values.yml , you can apply the configuration like this: helm upgrade \\ --install \\ # Install chart if it's not installed --namespace rustus \\ # k8s namespace --create-namespace \\ # Creates namespace if it doesn't exist --atomic \\ # Ensures that everything is deployed correctly --values \"values.yml\" \\ # Link to values.yml file \"rustus\" \\ # name of a release \"rustus/rustus\" # Name of the chart Persistence You can add PVC mount by editing persistence section. The most preferable way is to create PersistentVolume and PersistentVolumeClaim before installing this chart. After you created claim you can apply this values file to mount your claim into rustus. values.yml persistence : enabled : true existingClaim : \"rustus-pvc\" Warning Currently there's no ability to create multiple mounts and if you use file info storage you must specify the same directory as you specified for data storage. But it would be better to use other type of info-storage. Subcharts For example if you want to use redis as your info storage. values.yml env : RUSTUS_INFO_STORAGE : redis-info-storage RUSTUS_INFO_DB_DSN : redis://:pass@rustus-redis-master/0 redis : enabled : true redis , postgresql and mysql are subcharts. You can find information about configuration these subcharts here: Repo for redis; Repo for mysql; Repo for postgresql. In production you may ignore these subcharts to deploy your own redis or mysql or postgresql.","title":"Deployment"},{"location":"deploy/#deployment","text":"Deploying an application is always a challenge. Rustus was made to make deployment as easy as possible. Since Rustus works with files you have to be careful while scaling it. All rustus instances must have access to the same data and info storages. Info If you want to track you rustus instances with prometheus you can always get metrics at /metrics endpoint.","title":"Deployment"},{"location":"deploy/#docker-compose","text":"docker-compose.yml # This is super simple configuration version : \"3.7\" services : rustus : image : s3rius/rustus volumes : # Volume mounted to default data directory # So it's available across multiple containers. - rustus_data_volume:/app/data volumes : rustus_data_volume : After running docker compose up you will see rustus startup logs. If you want to deploy multiple rustus instances you can simply use config as this one: docker-compose.yml version : \"3.7\" services : proxy : image : jwilder/nginx-proxy:alpine container_name : proxy # Actual proxy ports. ports : - 8080:80 volumes : # This thing helps to locate containers # within this composition to generate nginx config. - /var/run/docker.sock:/tmp/docker.sock:ro rustus : image : s3rius/rustus ports : # Ports definition # To generate correct nginx config. - 1081 volumes : # Volume mounted to default data directory # So it's available across multiple containers. - rustus_data_volume:/app/data environment : # Idk why but without this variable # load balancing with jwilder/nginx-proxy doesn't work. VIRTUAL_HOST : localhost volumes : rustus_data_volume : # This is named volume The main idea is that traffic that comes into nginx-proxy is routed in one of multiple rustus containers. Here I used jwilder/nginx-proxy but you can use other reverse-proxies such as Nginx proxy , Traefik or Envoy proxy . Now you can run multiple rustus instances like this. docker compose up --scale rustus = 3 After that you can upload files to http://localhost:8080/files","title":"Docker compose"},{"location":"deploy/#kubernetes","text":"Configuration for Kubernetes is almost the same as for Docker. But the most preferable way is an official helm chart. Load balancing is done by Kubernetes, so you just have to create a volume to mount data and info directories.","title":"Kubernetes"},{"location":"deploy/#helm","text":"You can install rustus by running this set of commands: helm repo add \"rustus\" \"https://s3rius.github.io/rustus/helm_releases\" helm repo update helm install \"rustus\" \"rustus/rustus\"","title":"Helm"},{"location":"deploy/#configuration","text":"Since default deployment may not fit you. You can adjust it to satisfy your needs. You can do it easily with helm. At first you need to save default values on disk. # You can download basic configuration by running helm show values \"rustus/rustus\" > values.yml Warning For production use you must provide and mount PersistentVolumeClaim in order to scale rustus. This helm chart has only one replica by default. You can read more about configuration below. After you done editing values.yml , you can apply the configuration like this: helm upgrade \\ --install \\ # Install chart if it's not installed --namespace rustus \\ # k8s namespace --create-namespace \\ # Creates namespace if it doesn't exist --atomic \\ # Ensures that everything is deployed correctly --values \"values.yml\" \\ # Link to values.yml file \"rustus\" \\ # name of a release \"rustus/rustus\" # Name of the chart","title":"Configuration"},{"location":"deploy/#persistence","text":"You can add PVC mount by editing persistence section. The most preferable way is to create PersistentVolume and PersistentVolumeClaim before installing this chart. After you created claim you can apply this values file to mount your claim into rustus. values.yml persistence : enabled : true existingClaim : \"rustus-pvc\" Warning Currently there's no ability to create multiple mounts and if you use file info storage you must specify the same directory as you specified for data storage. But it would be better to use other type of info-storage.","title":"Persistence"},{"location":"deploy/#subcharts","text":"For example if you want to use redis as your info storage. values.yml env : RUSTUS_INFO_STORAGE : redis-info-storage RUSTUS_INFO_DB_DSN : redis://:pass@rustus-redis-master/0 redis : enabled : true redis , postgresql and mysql are subcharts. You can find information about configuration these subcharts here: Repo for redis; Repo for mysql; Repo for postgresql. In production you may ignore these subcharts to deploy your own redis or mysql or postgresql.","title":"Subcharts"},{"location":"hooks/","text":"Rustus can notify about uploads using hooks. This is useful when you integrate rustus in your architecture. Apps can keep track of every upload using this feature. Rustus has different event types for different moments of an upload's lifecycle. pre-create - This hook means that someone wants to create an upload; post-create - someone successfully created an upload; post-receive - someone uploaded a new part of an upload; pre-terminate - someone wants to delete the upload; post-terminate - someone deleted upload; post-finish - someone finished uploading file. Note Pre-create and Pre-terminate hooks are very important. If at least one of hooks fails, upload creation or removal is canceled. But AMQP hooks won't cancel the upload, since it's non blocking type of hooks. Warning After creating final upload with concatenation extension, you won't receive post-create hook, but post-finish instead. Warning If you uploaded a whole file within one request with creation-with-upload extension, you won't receive post-create hook, but post-finish instead. You can disable some hooks by using --hooks parameter. CLI ENV rustus --hooks \"pre-create,post-create,post-receive,pre-terminate,post-terminate,post-finish\" export RUSTUS_HOOKS = \"pre-create,post-create,post-receive,pre-terminate,post-terminate,post-finish\" rustus Proxies If you have rustus behind proxy like nginx, please use --behind-proxy parameter. This parameter helps rustus resolve ip addresses using Forwarded and X-Forwarded-For . This option disabled by default for security purposes unless you can be sure that the Forwarded and X-Forwarded-For headers cannot be spoofed by the client. CLI ENV rustus --behind-proxy \"yes\" export RUSTUS_BEHIND_PROXY = \"yes\" rustus Format Information about every event is sent using JSON format. Format can be configured with --hooks-format parameter or RUSTUS_HOOKS_FORMAT environment variable. Available formats: default (will be replaced by v2 in the future) v2 (preferred format) tusd default v2 tusd Example Pydantic models JSON schema { \"upload\" : { \"id\" : \"3cd911fe-eba0-499a-b220-b1d1b947b80f\" , \"offset\" : 0 , \"length\" : 220 , \"path\" : null , \"created_at\" : 1658671969 , \"deferred_size\" : false , \"is_partial\" : false , \"is_final\" : false , \"parts\" : null , \"storage\" : \"file_storage\" , \"metadata\" : { \"filename\" \"shrek2.mkv\" } }, \"request\" : { \"URI\" : \"/files/\" , \"method\" : \"POST\" , \"remote_addr\" : \"127.0.0.1\" , \"headers\" : { \"host\" : \"rustus.localhost\" , \"upload-length\" : \"220\" , \"user-agent\" : \"curl/7.84.0\" , \"accept\" : \"*/*\" , \"upload-metadata\" : \"filename MTZNQl92aWRlby5tcDQ=\" } } } from datetime import datetime from typing import Dict , Optional from pydantic import BaseModel , IPvAnyAddress class Upload ( BaseModel ): \"\"\"Information about the upload.\"\"\" id : str offset : int length : int path : Optional [ str ] # Actually it's an int, # but pydantic can parse it as datetime. created_at : datetime deferred_size : bool is_partial : bool is_final : bool parts : Optional [ List [ str ]] storage : str metadata : Dict [ str , str ] class Request ( BaseModel ): \"\"\" Information about request. This request was direct cause of hook invocation. \"\"\" URI : str method : str remote_addr : Optional [ IPvAnyAddress ] headers : Dict [ str , str ] class Hook ( BaseModel ): \"\"\"Rustus hook.\"\"\" upload : Upload request : Request { \"title\" : \"Hook\" , \"type\" : \"object\" , \"properties\" : { \"upload\" : { \"$ref\" : \"#/definitions/Upload\" }, \"request\" : { \"$ref\" : \"#/definitions/Request\" } }, \"required\" : [ \"upload\" , \"request\" ], \"definitions\" : { \"Upload\" : { \"title\" : \"Upload\" , \"type\" : \"object\" , \"properties\" : { \"id\" : { \"title\" : \"Id\" , \"type\" : \"string\" }, \"offset\" : { \"title\" : \"Offset\" , \"type\" : \"integer\" }, \"length\" : { \"title\" : \"Length\" , \"type\" : \"integer\" }, \"path\" : { \"title\" : \"Path\" , \"type\" : \"string\" }, \"created_at\" : { \"title\" : \"Created At\" , \"type\" : \"integer\" }, \"deferred_size\" : { \"title\" : \"Deferred Size\" , \"type\" : \"boolean\" }, \"is_partial\" : { \"title\" : \"Is Partial\" , \"type\" : \"boolean\" }, \"is_final\" : { \"title\" : \"Is Final\" , \"type\" : \"boolean\" }, \"parts\" : { \"title\" : \"Parts\" , \"type\" : \"array\" , \"items\" : { \"type\" : \"string\" } }, \"storage\" : { \"title\" : \"Storage\" , \"type\" : \"string\" }, \"metadata\" : { \"title\" : \"Metadata\" , \"type\" : \"object\" , \"additionalProperties\" : { \"type\" : \"string\" } } }, \"required\" : [ \"id\" , \"offset\" , \"length\" , \"created_at\" , \"deferred_size\" , \"is_partial\" , \"is_final\" , \"storage\" , \"metadata\" ] }, \"Request\" : { \"title\" : \"Request\" , \"type\" : \"object\" , \"properties\" : { \"URI\" : { \"title\" : \"Uri\" , \"type\" : \"string\" }, \"method\" : { \"title\" : \"Method\" , \"type\" : \"string\" }, \"remote_addr\" : { \"title\" : \"Remote Addr\" , \"type\" : \"string\" , \"format\" : \"ipvanyaddress\" }, \"headers\" : { \"title\" : \"Headers\" , \"type\" : \"object\" , \"additionalProperties\" : { \"type\" : \"string\" } } }, \"required\" : [ \"URI\" , \"method\" , \"headers\" ] } } } Example Pydantic models JSON schema { \"upload\" : { \"id\" : \"3cd911fe-eba0-499a-b220-b1d1b947b80f\" , \"offset\" : 0 , \"length\" : 220 , \"path\" : null , \"created_at\" : 1658671969 , \"deferred_size\" : false , \"is_partial\" : false , \"is_final\" : false , \"parts\" : null , \"storage\" : \"file_storage\" , \"metadata\" : { \"filename\" \"shrek2.mkv\" } }, \"request\" : { \"uri\" : \"/files/\" , \"method\" : \"POST\" , \"remote_addr\" : \"127.0.0.1\" , \"headers\" : { \"host\" : \"rustus.localhost\" , \"upload-length\" : \"220\" , \"user-agent\" : \"curl/7.84.0\" , \"accept\" : \"*/*\" , \"upload-metadata\" : \"filename MTZNQl92aWRlby5tcDQ=\" } } } from datetime import datetime from typing import Dict , Optional from pydantic import BaseModel , IPvAnyAddress class Upload ( BaseModel ): \"\"\"Information about the upload.\"\"\" id : str offset : int length : int path : Optional [ str ] # Actually it's an int, # but pydantic can parse it as datetime. created_at : datetime deferred_size : bool is_partial : bool is_final : bool parts : Optional [ List [ str ]] storage : str metadata : Dict [ str , str ] class Request ( BaseModel ): \"\"\" Information about request. This request was direct cause of hook invocation. \"\"\" uri : str method : str remote_addr : Optional [ IPvAnyAddress ] headers : Dict [ str , str ] class Hook ( BaseModel ): \"\"\"Rustus hook.\"\"\" upload : Upload request : Request { \"title\" : \"Hook\" , \"type\" : \"object\" , \"properties\" : { \"upload\" : { \"$ref\" : \"#/definitions/Upload\" }, \"request\" : { \"$ref\" : \"#/definitions/Request\" } }, \"required\" : [ \"upload\" , \"request\" ], \"definitions\" : { \"Upload\" : { \"title\" : \"Upload\" , \"type\" : \"object\" , \"properties\" : { \"id\" : { \"title\" : \"Id\" , \"type\" : \"string\" }, \"offset\" : { \"title\" : \"Offset\" , \"type\" : \"integer\" }, \"length\" : { \"title\" : \"Length\" , \"type\" : \"integer\" }, \"path\" : { \"title\" : \"Path\" , \"type\" : \"string\" }, \"created_at\" : { \"title\" : \"Created At\" , \"type\" : \"integer\" }, \"deferred_size\" : { \"title\" : \"Deferred Size\" , \"type\" : \"boolean\" }, \"is_partial\" : { \"title\" : \"Is Partial\" , \"type\" : \"boolean\" }, \"is_final\" : { \"title\" : \"Is Final\" , \"type\" : \"boolean\" }, \"parts\" : { \"title\" : \"Parts\" , \"type\" : \"array\" , \"items\" : { \"type\" : \"string\" } }, \"storage\" : { \"title\" : \"Storage\" , \"type\" : \"string\" }, \"metadata\" : { \"title\" : \"Metadata\" , \"type\" : \"object\" , \"additionalProperties\" : { \"type\" : \"string\" } } }, \"required\" : [ \"id\" , \"offset\" , \"length\" , \"created_at\" , \"deferred_size\" , \"is_partial\" , \"is_final\" , \"storage\" , \"metadata\" ] }, \"Request\" : { \"title\" : \"Request\" , \"type\" : \"object\" , \"properties\" : { \"uri\" : { \"title\" : \"Uri\" , \"type\" : \"string\" }, \"method\" : { \"title\" : \"Method\" , \"type\" : \"string\" }, \"remote_addr\" : { \"title\" : \"Remote Addr\" , \"type\" : \"string\" , \"format\" : \"ipvanyaddress\" }, \"headers\" : { \"title\" : \"Headers\" , \"type\" : \"object\" , \"additionalProperties\" : { \"type\" : \"string\" } } }, \"required\" : [ \"uri\" , \"method\" , \"headers\" ] } } } Example Pydantic models JSON schema { \"Upload\" : { \"ID\" : \"317e1429-61f3-4631-a480-c50207b69ee4\" , \"Offset\" : 0 , \"Size\" : 16392985 , \"IsFinal\" : false , \"IsPartial\" : false , \"PartialUploads\" : null , \"SizeIsDeferred\" : false , \"MetaData\" : { \"filename\" : \"shrek2.mkv\" }, \"Storage\" : { \"Type\" : \"file_storage\" , \"Path\" : null } }, \"HTTPRequest\" : { \"URI\" : \"/files/\" , \"Method\" : \"POST\" , \"RemoteAddr\" : \"127.0.0.1\" , \"Header\" : { \"content-length\" : [ \"0\" ], \"upload-length\" : [ \"16392985\" ], \"user-agent\" : [ \"python-requests/2.27.1\" ], \"host\" : [ \"rustus.localhost\" ], \"accept\" : [ \"*/*\" ], \"upload-metadata\" : [ \"filename MTZNQl92aWRlby5tcDQ=\" ], \"tus-resumable\" : [ \"1.0.0\" ] } } } from typing import Dict , List , Optional from pydantic import BaseModel , IPvAnyAddress class Request ( BaseModel ): \"\"\" Information about request. This request was direct cause of hook invocation. \"\"\" URI : str Method : str RemoteAddr : IPvAnyAddress Header : Dict [ str , List [ str ]] class Storage ( BaseModel ): \"\"\"Information where upload is stored.\"\"\" Type : str Path : Optional [ str ] class Upload ( BaseModel ): \"\"\"Information about the upload.\"\"\" ID : str Offset : int Size : int IsFinal : bool IsPartial : bool PartialUploads : Optional [ List [ str ]] SizeIsDeferred : bool MetaData : Dict [ str , str ] Storage : Storage class Hook ( BaseModel ): \"\"\"Rustus hook.\"\"\" Upload : Upload HTTPRequest : Request { \"title\" : \"Hook\" , \"type\" : \"object\" , \"properties\" : { \"Upload\" : { \"$ref\" : \"#/definitions/Upload\" }, \"HTTPRequest\" : { \"$ref\" : \"#/definitions/Request\" } }, \"required\" : [ \"Upload\" , \"HTTPRequest\" ], \"definitions\" : { \"Storage\" : { \"title\" : \"Storage\" , \"type\" : \"object\" , \"properties\" : { \"Type\" : { \"title\" : \"Type\" , \"type\" : \"string\" }, \"Path\" : { \"title\" : \"Path\" , \"type\" : \"string\" } }, \"required\" : [ \"Type\" ] }, \"Upload\" : { \"title\" : \"Upload\" , \"type\" : \"object\" , \"properties\" : { \"ID\" : { \"title\" : \"Id\" , \"type\" : \"string\" }, \"Offset\" : { \"title\" : \"Offset\" , \"type\" : \"integer\" }, \"Size\" : { \"title\" : \"Size\" , \"type\" : \"integer\" }, \"IsFinal\" : { \"title\" : \"Isfinal\" , \"type\" : \"boolean\" }, \"IsPartial\" : { \"title\" : \"Ispartial\" , \"type\" : \"boolean\" }, \"PartialUploads\" : { \"title\" : \"Partialuploads\" , \"type\" : \"array\" , \"items\" : { \"type\" : \"string\" } }, \"SizeIsDeferred\" : { \"title\" : \"Sizeisdeferred\" , \"type\" : \"boolean\" }, \"MetaData\" : { \"title\" : \"MetaData\" , \"type\" : \"object\" , \"additionalProperties\" : { \"type\" : \"string\" } }, \"Storage\" : { \"$ref\" : \"#/definitions/Storage\" } }, \"required\" : [ \"ID\" , \"Offset\" , \"Size\" , \"IsFinal\" , \"IsPartial\" , \"SizeIsDeferred\" , \"MetaData\" , \"Storage\" ] }, \"Request\" : { \"title\" : \"Request\" , \"type\" : \"object\" , \"properties\" : { \"URI\" : { \"title\" : \"Uri\" , \"type\" : \"string\" }, \"Method\" : { \"title\" : \"Method\" , \"type\" : \"string\" }, \"RemoteAddr\" : { \"title\" : \"Remoteaddr\" , \"type\" : \"string\" , \"format\" : \"ipvanyaddress\" }, \"Header\" : { \"title\" : \"Header\" , \"type\" : \"object\" , \"additionalProperties\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"string\" } } } }, \"required\" : [ \"URI\" , \"Method\" , \"RemoteAddr\" , \"Header\" ] } } } Hook types Rustus offers multiple types of Hooks. We'll take a brief look on each type. File hooks Rustus can work with two types of file hooks. Single file hook Hooks directory The main difference is that in case if use single file hook, hook name is passed as a command line argument to an executable file, but if you use hooks directory then hook name is used to determine a file to call. Let's take a look at the examples. Parameters: * --hooks-file - path to an executable file; * --hooks-dir - path to a directory with executable files. single_file_hook.sh #!/bin/bash # Hook name would be \"pre-create\", \"post-create\" and so on. HOOK_NAME = \" $1 \" HOOK_INFO = \" $2 \" MEME = \" $( echo \" $HOOK_INFO \" | jq \".upload .metadata .meme\" | xargs ) \" # Here we check if name in metadata is equal to pepe. if [[ $MEME = \"pepe\" ]] ; then echo \"This meme isn't allowed\" 1 > & 2 ; exit 1 fi As you can see it uses first CLI parameter as a hook name and all hook data is received from the second one. Let's make it executable and make rustus use this hook. CLI ENV chmod +x \"hooks/single_file_hook.sh\" rustus --hooks-file \"hooks/single_file_hook.sh\" chmod +x \"hooks/single_file_hook.sh\" export RUSTUS_HOOKS_FILE = \"hooks/single_file_hook.sh\" rustus If you would like to use directory hooks you must create directory with the following structure: hooks \u251c\u2500\u2500 post-create \u251c\u2500\u2500 post-finish \u251c\u2500\u2500 post-receive \u251c\u2500\u2500 post-terminate \u2514\u2500\u2500 pre-create Warning If some hook file isn't found, rustus throws an error. In case with pre-create hook it can be fatal. Http Hooks Http hooks use HTTP to send POST requests to some endpoint. Configuration parameters: --hooks-http-proxy-headers - list of headers to proxy (separated by commas) to listener's endpoint; --hooks-http-urls - list of absolute urls to send request to (separated by commas). Note Hook names are passed as header called Hook-Name . CLI ENV rustus --hooks-http-urls \"https://httpbin.org/post\" \\ --hooks-http-proxy-headers \"Authorization\" export RUSTUS_HOOKS_HTTP_URLS = \"https://httpbin.org/post\" export RUSTUS_HOOKS_HTTP_PROXY_HEADERS = \"Authorization\" rustus Example application To be more verbose let's create simple web server that handles uploads using FastAPI . At first we need to install dependencies using pip. pip install fastapi uvicorn server.py from fastapi import FastAPI , Header , HTTPException from typing import Optional app = FastAPI () @app . post ( \"/hooks\" ) def hook ( authorization : Optional [ str ] = Header ( None ), hook_name : Optional [ str ] = Header ( None ), ): print ( f \"Received: { hook_name } \" ) if authorization != \"Bearer jwt\" : raise HTTPException ( 401 ) return None Now we can run this server using uvicorn. uvicorn server:app --port 8080 Let's configure rustus to use this server as a hook receiver. CLI ENV rustus --hooks-http-urls \"http://localhost:8000/hooks\" \\ --hooks-http-proxy-headers \"Authorization\" export RUSTUS_HOOKS_HTTP_URLS = \"http://localhost:8000/hooks\" export RUSTUS_HOOKS_HTTP_PROXY_HEADERS = \"Authorization\" rustus That's it. AMQP hooks AMQP hooks are used to store information about uploads using RabbitMQ. Configuration parameters: --hooks-amqp-url - connection string to RabbitMQ; --hooks-amqp-queues-prefix - prefix for queues for every event queue; --hooks-amqp-exchange - name of exchange to use; --hooks-amqp-declare-exchange - creates exchange on startup; --hooks-amqp-exchange-kind - kind of exchange to connect to; --hooks-amqp-declare-queues - creates all queues and binds them to exchange; --hooks-amqp-durable-exchange - adds durability to created exchange; --hooks-amqp-durable-queues - adds durability to created; --hooks-amqp-celery - adds headers required by Celery ; --hooks-amqp-routing-key - routing key for all messages passed to exchange. If no hooks_amqp_routing_key specified, rustus will send all messages with different routing keys. Named like {prefix}.{event type} . Eg rustus.pre-create and so on. Otherwise, it will use only one routing key and only one queue! Warning Since we can't really track message delivery and responses Rustus won't stop a current upload in any case. CLI ENV rustus --hooks-amqp-url \"amqp://guest:guest@localhost:5672\" \\ --hooks-amqp-queues-prefix \"rustus_prefix\" \\ --hooks-amqp-exchange \"rustus\" \\ --hooks-amqp-exchange-kind \"topic\" \\ --hooks-amqp-routing-key \"route66\" \\ --hooks-amqp-declare-exchange \"yes\" \\ --hooks-amqp-declare-queues \"yes\" \\ --hooks-amqp-durable-exchange \"yes\" \\ --hooks-amqp-durable-queues \"yes\" \\ --hooks-amqp-celery \"yes\" export RUSTUS_HOOKS_AMQP_URL = \"amqp://guest:guest@localhost:5672\" export RUSTUS_HOOKS_AMQP_QUEUES_PREFIX = \"rustus_prefix\" export RUSTUS_HOOKS_AMQP_EXCHANGE = \"rustus\" export RUSTUS_HOOKS_AMQP_EXCHANGE_KIND = \"topic\" export RUSTUS_HOOKS_AMQP_ROUTING_KEY = \"route66\" export RUSTUS_HOOKS_AMQP_DECLARE_EXCHANGE = \"yes\" export RUSTUS_HOOKS_AMQP_DECLARE_QUEUES = \"yes\" export RUSTUS_HOOKS_AMQP_DURABLE_EXCHANGE = \"yes\" export RUSTUS_HOOKS_AMQP_DURABLE_QUEUES = \"yes\" export RUSTUS_HOOKS_AMQP_CELERY = \"yes\" rustus Using Rustus with Celery Rustus has a cool integration with Celery . Let's build a Celery application that handles rustus hooks. At first, we need to install Celery itself. pip install celery Now we can create a file called \"celery.py\" in a directory \"rustus_celery\". This file contains code that handles celery tasks. rustus_celery/celery.py import celery app = celery . Celery ( \"rustus_celery\" ) app . conf . update ( broker_url = \"amqp://guest:guest@localhost:5672\" , ) @app . task ( name = \"rustus.pre-create\" ) def post_create ( data ): print ( f \"PRE CREATE: { data } \" ) @app . task ( name = \"rustus.post-create\" ) def post_create ( data ): print ( f \"POST CREATE: { data } \" ) @app . task ( name = \"rustus.post-finish\" ) def post_finish ( data ): print ( f \"POST FINISH: { data } \" ) @app . task ( name = \"rustus.post-terminate\" ) def post_terminate ( data ): print ( f \"POST TERMINATE: { data } \" ) @app . task ( name = \"rustus.post-receive\" ) def post_receive ( data ): print ( f \"POST RECEIVE: { data } \" ) Info Every task has its name. You must use these names in order to handle tasks. Now we can run our celery worker to start executing tasks. celery -A rustus_celery After starting celery worker you can run Rustus with these parameters. The most important parameter is --hooks-amqp-celery , because it adds required by Celery headers to every message. CLI ENV rustus --hooks-amqp-url \"amqp://guest:guest@localhost:5672\" \\ --hooks-amqp-exchange \"celery\" \\ --hooks-amqp-exchange-kind \"direct\" \\ --hooks-amqp-routing-key \"celery\" \\ --hooks-amqp-celery \"yes\" export RUSTUS_HOOKS_AMQP_URL = \"amqp://guest:guest@localhost:5672\" export RUSTUS_HOOKS_AMQP_EXCHANGE = \"celery\" export RUSTUS_HOOKS_AMQP_EXCHANGE_KIND = \"direct\" export RUSTUS_HOOKS_AMQP_ROUTING_KEY = \"celery\" export RUSTUS_HOOKS_AMQP_CELERY = \"yes\" rustus","title":"Setting up hooks"},{"location":"hooks/#proxies","text":"If you have rustus behind proxy like nginx, please use --behind-proxy parameter. This parameter helps rustus resolve ip addresses using Forwarded and X-Forwarded-For . This option disabled by default for security purposes unless you can be sure that the Forwarded and X-Forwarded-For headers cannot be spoofed by the client. CLI ENV rustus --behind-proxy \"yes\" export RUSTUS_BEHIND_PROXY = \"yes\" rustus","title":"Proxies"},{"location":"hooks/#format","text":"Information about every event is sent using JSON format. Format can be configured with --hooks-format parameter or RUSTUS_HOOKS_FORMAT environment variable. Available formats: default (will be replaced by v2 in the future) v2 (preferred format) tusd default v2 tusd Example Pydantic models JSON schema { \"upload\" : { \"id\" : \"3cd911fe-eba0-499a-b220-b1d1b947b80f\" , \"offset\" : 0 , \"length\" : 220 , \"path\" : null , \"created_at\" : 1658671969 , \"deferred_size\" : false , \"is_partial\" : false , \"is_final\" : false , \"parts\" : null , \"storage\" : \"file_storage\" , \"metadata\" : { \"filename\" \"shrek2.mkv\" } }, \"request\" : { \"URI\" : \"/files/\" , \"method\" : \"POST\" , \"remote_addr\" : \"127.0.0.1\" , \"headers\" : { \"host\" : \"rustus.localhost\" , \"upload-length\" : \"220\" , \"user-agent\" : \"curl/7.84.0\" , \"accept\" : \"*/*\" , \"upload-metadata\" : \"filename MTZNQl92aWRlby5tcDQ=\" } } } from datetime import datetime from typing import Dict , Optional from pydantic import BaseModel , IPvAnyAddress class Upload ( BaseModel ): \"\"\"Information about the upload.\"\"\" id : str offset : int length : int path : Optional [ str ] # Actually it's an int, # but pydantic can parse it as datetime. created_at : datetime deferred_size : bool is_partial : bool is_final : bool parts : Optional [ List [ str ]] storage : str metadata : Dict [ str , str ] class Request ( BaseModel ): \"\"\" Information about request. This request was direct cause of hook invocation. \"\"\" URI : str method : str remote_addr : Optional [ IPvAnyAddress ] headers : Dict [ str , str ] class Hook ( BaseModel ): \"\"\"Rustus hook.\"\"\" upload : Upload request : Request { \"title\" : \"Hook\" , \"type\" : \"object\" , \"properties\" : { \"upload\" : { \"$ref\" : \"#/definitions/Upload\" }, \"request\" : { \"$ref\" : \"#/definitions/Request\" } }, \"required\" : [ \"upload\" , \"request\" ], \"definitions\" : { \"Upload\" : { \"title\" : \"Upload\" , \"type\" : \"object\" , \"properties\" : { \"id\" : { \"title\" : \"Id\" , \"type\" : \"string\" }, \"offset\" : { \"title\" : \"Offset\" , \"type\" : \"integer\" }, \"length\" : { \"title\" : \"Length\" , \"type\" : \"integer\" }, \"path\" : { \"title\" : \"Path\" , \"type\" : \"string\" }, \"created_at\" : { \"title\" : \"Created At\" , \"type\" : \"integer\" }, \"deferred_size\" : { \"title\" : \"Deferred Size\" , \"type\" : \"boolean\" }, \"is_partial\" : { \"title\" : \"Is Partial\" , \"type\" : \"boolean\" }, \"is_final\" : { \"title\" : \"Is Final\" , \"type\" : \"boolean\" }, \"parts\" : { \"title\" : \"Parts\" , \"type\" : \"array\" , \"items\" : { \"type\" : \"string\" } }, \"storage\" : { \"title\" : \"Storage\" , \"type\" : \"string\" }, \"metadata\" : { \"title\" : \"Metadata\" , \"type\" : \"object\" , \"additionalProperties\" : { \"type\" : \"string\" } } }, \"required\" : [ \"id\" , \"offset\" , \"length\" , \"created_at\" , \"deferred_size\" , \"is_partial\" , \"is_final\" , \"storage\" , \"metadata\" ] }, \"Request\" : { \"title\" : \"Request\" , \"type\" : \"object\" , \"properties\" : { \"URI\" : { \"title\" : \"Uri\" , \"type\" : \"string\" }, \"method\" : { \"title\" : \"Method\" , \"type\" : \"string\" }, \"remote_addr\" : { \"title\" : \"Remote Addr\" , \"type\" : \"string\" , \"format\" : \"ipvanyaddress\" }, \"headers\" : { \"title\" : \"Headers\" , \"type\" : \"object\" , \"additionalProperties\" : { \"type\" : \"string\" } } }, \"required\" : [ \"URI\" , \"method\" , \"headers\" ] } } } Example Pydantic models JSON schema { \"upload\" : { \"id\" : \"3cd911fe-eba0-499a-b220-b1d1b947b80f\" , \"offset\" : 0 , \"length\" : 220 , \"path\" : null , \"created_at\" : 1658671969 , \"deferred_size\" : false , \"is_partial\" : false , \"is_final\" : false , \"parts\" : null , \"storage\" : \"file_storage\" , \"metadata\" : { \"filename\" \"shrek2.mkv\" } }, \"request\" : { \"uri\" : \"/files/\" , \"method\" : \"POST\" , \"remote_addr\" : \"127.0.0.1\" , \"headers\" : { \"host\" : \"rustus.localhost\" , \"upload-length\" : \"220\" , \"user-agent\" : \"curl/7.84.0\" , \"accept\" : \"*/*\" , \"upload-metadata\" : \"filename MTZNQl92aWRlby5tcDQ=\" } } } from datetime import datetime from typing import Dict , Optional from pydantic import BaseModel , IPvAnyAddress class Upload ( BaseModel ): \"\"\"Information about the upload.\"\"\" id : str offset : int length : int path : Optional [ str ] # Actually it's an int, # but pydantic can parse it as datetime. created_at : datetime deferred_size : bool is_partial : bool is_final : bool parts : Optional [ List [ str ]] storage : str metadata : Dict [ str , str ] class Request ( BaseModel ): \"\"\" Information about request. This request was direct cause of hook invocation. \"\"\" uri : str method : str remote_addr : Optional [ IPvAnyAddress ] headers : Dict [ str , str ] class Hook ( BaseModel ): \"\"\"Rustus hook.\"\"\" upload : Upload request : Request { \"title\" : \"Hook\" , \"type\" : \"object\" , \"properties\" : { \"upload\" : { \"$ref\" : \"#/definitions/Upload\" }, \"request\" : { \"$ref\" : \"#/definitions/Request\" } }, \"required\" : [ \"upload\" , \"request\" ], \"definitions\" : { \"Upload\" : { \"title\" : \"Upload\" , \"type\" : \"object\" , \"properties\" : { \"id\" : { \"title\" : \"Id\" , \"type\" : \"string\" }, \"offset\" : { \"title\" : \"Offset\" , \"type\" : \"integer\" }, \"length\" : { \"title\" : \"Length\" , \"type\" : \"integer\" }, \"path\" : { \"title\" : \"Path\" , \"type\" : \"string\" }, \"created_at\" : { \"title\" : \"Created At\" , \"type\" : \"integer\" }, \"deferred_size\" : { \"title\" : \"Deferred Size\" , \"type\" : \"boolean\" }, \"is_partial\" : { \"title\" : \"Is Partial\" , \"type\" : \"boolean\" }, \"is_final\" : { \"title\" : \"Is Final\" , \"type\" : \"boolean\" }, \"parts\" : { \"title\" : \"Parts\" , \"type\" : \"array\" , \"items\" : { \"type\" : \"string\" } }, \"storage\" : { \"title\" : \"Storage\" , \"type\" : \"string\" }, \"metadata\" : { \"title\" : \"Metadata\" , \"type\" : \"object\" , \"additionalProperties\" : { \"type\" : \"string\" } } }, \"required\" : [ \"id\" , \"offset\" , \"length\" , \"created_at\" , \"deferred_size\" , \"is_partial\" , \"is_final\" , \"storage\" , \"metadata\" ] }, \"Request\" : { \"title\" : \"Request\" , \"type\" : \"object\" , \"properties\" : { \"uri\" : { \"title\" : \"Uri\" , \"type\" : \"string\" }, \"method\" : { \"title\" : \"Method\" , \"type\" : \"string\" }, \"remote_addr\" : { \"title\" : \"Remote Addr\" , \"type\" : \"string\" , \"format\" : \"ipvanyaddress\" }, \"headers\" : { \"title\" : \"Headers\" , \"type\" : \"object\" , \"additionalProperties\" : { \"type\" : \"string\" } } }, \"required\" : [ \"uri\" , \"method\" , \"headers\" ] } } } Example Pydantic models JSON schema { \"Upload\" : { \"ID\" : \"317e1429-61f3-4631-a480-c50207b69ee4\" , \"Offset\" : 0 , \"Size\" : 16392985 , \"IsFinal\" : false , \"IsPartial\" : false , \"PartialUploads\" : null , \"SizeIsDeferred\" : false , \"MetaData\" : { \"filename\" : \"shrek2.mkv\" }, \"Storage\" : { \"Type\" : \"file_storage\" , \"Path\" : null } }, \"HTTPRequest\" : { \"URI\" : \"/files/\" , \"Method\" : \"POST\" , \"RemoteAddr\" : \"127.0.0.1\" , \"Header\" : { \"content-length\" : [ \"0\" ], \"upload-length\" : [ \"16392985\" ], \"user-agent\" : [ \"python-requests/2.27.1\" ], \"host\" : [ \"rustus.localhost\" ], \"accept\" : [ \"*/*\" ], \"upload-metadata\" : [ \"filename MTZNQl92aWRlby5tcDQ=\" ], \"tus-resumable\" : [ \"1.0.0\" ] } } } from typing import Dict , List , Optional from pydantic import BaseModel , IPvAnyAddress class Request ( BaseModel ): \"\"\" Information about request. This request was direct cause of hook invocation. \"\"\" URI : str Method : str RemoteAddr : IPvAnyAddress Header : Dict [ str , List [ str ]] class Storage ( BaseModel ): \"\"\"Information where upload is stored.\"\"\" Type : str Path : Optional [ str ] class Upload ( BaseModel ): \"\"\"Information about the upload.\"\"\" ID : str Offset : int Size : int IsFinal : bool IsPartial : bool PartialUploads : Optional [ List [ str ]] SizeIsDeferred : bool MetaData : Dict [ str , str ] Storage : Storage class Hook ( BaseModel ): \"\"\"Rustus hook.\"\"\" Upload : Upload HTTPRequest : Request { \"title\" : \"Hook\" , \"type\" : \"object\" , \"properties\" : { \"Upload\" : { \"$ref\" : \"#/definitions/Upload\" }, \"HTTPRequest\" : { \"$ref\" : \"#/definitions/Request\" } }, \"required\" : [ \"Upload\" , \"HTTPRequest\" ], \"definitions\" : { \"Storage\" : { \"title\" : \"Storage\" , \"type\" : \"object\" , \"properties\" : { \"Type\" : { \"title\" : \"Type\" , \"type\" : \"string\" }, \"Path\" : { \"title\" : \"Path\" , \"type\" : \"string\" } }, \"required\" : [ \"Type\" ] }, \"Upload\" : { \"title\" : \"Upload\" , \"type\" : \"object\" , \"properties\" : { \"ID\" : { \"title\" : \"Id\" , \"type\" : \"string\" }, \"Offset\" : { \"title\" : \"Offset\" , \"type\" : \"integer\" }, \"Size\" : { \"title\" : \"Size\" , \"type\" : \"integer\" }, \"IsFinal\" : { \"title\" : \"Isfinal\" , \"type\" : \"boolean\" }, \"IsPartial\" : { \"title\" : \"Ispartial\" , \"type\" : \"boolean\" }, \"PartialUploads\" : { \"title\" : \"Partialuploads\" , \"type\" : \"array\" , \"items\" : { \"type\" : \"string\" } }, \"SizeIsDeferred\" : { \"title\" : \"Sizeisdeferred\" , \"type\" : \"boolean\" }, \"MetaData\" : { \"title\" : \"MetaData\" , \"type\" : \"object\" , \"additionalProperties\" : { \"type\" : \"string\" } }, \"Storage\" : { \"$ref\" : \"#/definitions/Storage\" } }, \"required\" : [ \"ID\" , \"Offset\" , \"Size\" , \"IsFinal\" , \"IsPartial\" , \"SizeIsDeferred\" , \"MetaData\" , \"Storage\" ] }, \"Request\" : { \"title\" : \"Request\" , \"type\" : \"object\" , \"properties\" : { \"URI\" : { \"title\" : \"Uri\" , \"type\" : \"string\" }, \"Method\" : { \"title\" : \"Method\" , \"type\" : \"string\" }, \"RemoteAddr\" : { \"title\" : \"Remoteaddr\" , \"type\" : \"string\" , \"format\" : \"ipvanyaddress\" }, \"Header\" : { \"title\" : \"Header\" , \"type\" : \"object\" , \"additionalProperties\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"string\" } } } }, \"required\" : [ \"URI\" , \"Method\" , \"RemoteAddr\" , \"Header\" ] } } }","title":"Format"},{"location":"hooks/#hook-types","text":"Rustus offers multiple types of Hooks. We'll take a brief look on each type.","title":"Hook types"},{"location":"hooks/#file-hooks","text":"Rustus can work with two types of file hooks. Single file hook Hooks directory The main difference is that in case if use single file hook, hook name is passed as a command line argument to an executable file, but if you use hooks directory then hook name is used to determine a file to call. Let's take a look at the examples. Parameters: * --hooks-file - path to an executable file; * --hooks-dir - path to a directory with executable files. single_file_hook.sh #!/bin/bash # Hook name would be \"pre-create\", \"post-create\" and so on. HOOK_NAME = \" $1 \" HOOK_INFO = \" $2 \" MEME = \" $( echo \" $HOOK_INFO \" | jq \".upload .metadata .meme\" | xargs ) \" # Here we check if name in metadata is equal to pepe. if [[ $MEME = \"pepe\" ]] ; then echo \"This meme isn't allowed\" 1 > & 2 ; exit 1 fi As you can see it uses first CLI parameter as a hook name and all hook data is received from the second one. Let's make it executable and make rustus use this hook. CLI ENV chmod +x \"hooks/single_file_hook.sh\" rustus --hooks-file \"hooks/single_file_hook.sh\" chmod +x \"hooks/single_file_hook.sh\" export RUSTUS_HOOKS_FILE = \"hooks/single_file_hook.sh\" rustus If you would like to use directory hooks you must create directory with the following structure: hooks \u251c\u2500\u2500 post-create \u251c\u2500\u2500 post-finish \u251c\u2500\u2500 post-receive \u251c\u2500\u2500 post-terminate \u2514\u2500\u2500 pre-create Warning If some hook file isn't found, rustus throws an error. In case with pre-create hook it can be fatal.","title":"File hooks"},{"location":"hooks/#http-hooks","text":"Http hooks use HTTP to send POST requests to some endpoint. Configuration parameters: --hooks-http-proxy-headers - list of headers to proxy (separated by commas) to listener's endpoint; --hooks-http-urls - list of absolute urls to send request to (separated by commas). Note Hook names are passed as header called Hook-Name . CLI ENV rustus --hooks-http-urls \"https://httpbin.org/post\" \\ --hooks-http-proxy-headers \"Authorization\" export RUSTUS_HOOKS_HTTP_URLS = \"https://httpbin.org/post\" export RUSTUS_HOOKS_HTTP_PROXY_HEADERS = \"Authorization\" rustus","title":"Http Hooks"},{"location":"hooks/#example-application","text":"To be more verbose let's create simple web server that handles uploads using FastAPI . At first we need to install dependencies using pip. pip install fastapi uvicorn server.py from fastapi import FastAPI , Header , HTTPException from typing import Optional app = FastAPI () @app . post ( \"/hooks\" ) def hook ( authorization : Optional [ str ] = Header ( None ), hook_name : Optional [ str ] = Header ( None ), ): print ( f \"Received: { hook_name } \" ) if authorization != \"Bearer jwt\" : raise HTTPException ( 401 ) return None Now we can run this server using uvicorn. uvicorn server:app --port 8080 Let's configure rustus to use this server as a hook receiver. CLI ENV rustus --hooks-http-urls \"http://localhost:8000/hooks\" \\ --hooks-http-proxy-headers \"Authorization\" export RUSTUS_HOOKS_HTTP_URLS = \"http://localhost:8000/hooks\" export RUSTUS_HOOKS_HTTP_PROXY_HEADERS = \"Authorization\" rustus That's it.","title":"Example application"},{"location":"hooks/#amqp-hooks","text":"AMQP hooks are used to store information about uploads using RabbitMQ. Configuration parameters: --hooks-amqp-url - connection string to RabbitMQ; --hooks-amqp-queues-prefix - prefix for queues for every event queue; --hooks-amqp-exchange - name of exchange to use; --hooks-amqp-declare-exchange - creates exchange on startup; --hooks-amqp-exchange-kind - kind of exchange to connect to; --hooks-amqp-declare-queues - creates all queues and binds them to exchange; --hooks-amqp-durable-exchange - adds durability to created exchange; --hooks-amqp-durable-queues - adds durability to created; --hooks-amqp-celery - adds headers required by Celery ; --hooks-amqp-routing-key - routing key for all messages passed to exchange. If no hooks_amqp_routing_key specified, rustus will send all messages with different routing keys. Named like {prefix}.{event type} . Eg rustus.pre-create and so on. Otherwise, it will use only one routing key and only one queue! Warning Since we can't really track message delivery and responses Rustus won't stop a current upload in any case. CLI ENV rustus --hooks-amqp-url \"amqp://guest:guest@localhost:5672\" \\ --hooks-amqp-queues-prefix \"rustus_prefix\" \\ --hooks-amqp-exchange \"rustus\" \\ --hooks-amqp-exchange-kind \"topic\" \\ --hooks-amqp-routing-key \"route66\" \\ --hooks-amqp-declare-exchange \"yes\" \\ --hooks-amqp-declare-queues \"yes\" \\ --hooks-amqp-durable-exchange \"yes\" \\ --hooks-amqp-durable-queues \"yes\" \\ --hooks-amqp-celery \"yes\" export RUSTUS_HOOKS_AMQP_URL = \"amqp://guest:guest@localhost:5672\" export RUSTUS_HOOKS_AMQP_QUEUES_PREFIX = \"rustus_prefix\" export RUSTUS_HOOKS_AMQP_EXCHANGE = \"rustus\" export RUSTUS_HOOKS_AMQP_EXCHANGE_KIND = \"topic\" export RUSTUS_HOOKS_AMQP_ROUTING_KEY = \"route66\" export RUSTUS_HOOKS_AMQP_DECLARE_EXCHANGE = \"yes\" export RUSTUS_HOOKS_AMQP_DECLARE_QUEUES = \"yes\" export RUSTUS_HOOKS_AMQP_DURABLE_EXCHANGE = \"yes\" export RUSTUS_HOOKS_AMQP_DURABLE_QUEUES = \"yes\" export RUSTUS_HOOKS_AMQP_CELERY = \"yes\" rustus","title":"AMQP hooks"},{"location":"hooks/#using-rustus-with-celery","text":"Rustus has a cool integration with Celery . Let's build a Celery application that handles rustus hooks. At first, we need to install Celery itself. pip install celery Now we can create a file called \"celery.py\" in a directory \"rustus_celery\". This file contains code that handles celery tasks. rustus_celery/celery.py import celery app = celery . Celery ( \"rustus_celery\" ) app . conf . update ( broker_url = \"amqp://guest:guest@localhost:5672\" , ) @app . task ( name = \"rustus.pre-create\" ) def post_create ( data ): print ( f \"PRE CREATE: { data } \" ) @app . task ( name = \"rustus.post-create\" ) def post_create ( data ): print ( f \"POST CREATE: { data } \" ) @app . task ( name = \"rustus.post-finish\" ) def post_finish ( data ): print ( f \"POST FINISH: { data } \" ) @app . task ( name = \"rustus.post-terminate\" ) def post_terminate ( data ): print ( f \"POST TERMINATE: { data } \" ) @app . task ( name = \"rustus.post-receive\" ) def post_receive ( data ): print ( f \"POST RECEIVE: { data } \" ) Info Every task has its name. You must use these names in order to handle tasks. Now we can run our celery worker to start executing tasks. celery -A rustus_celery After starting celery worker you can run Rustus with these parameters. The most important parameter is --hooks-amqp-celery , because it adds required by Celery headers to every message. CLI ENV rustus --hooks-amqp-url \"amqp://guest:guest@localhost:5672\" \\ --hooks-amqp-exchange \"celery\" \\ --hooks-amqp-exchange-kind \"direct\" \\ --hooks-amqp-routing-key \"celery\" \\ --hooks-amqp-celery \"yes\" export RUSTUS_HOOKS_AMQP_URL = \"amqp://guest:guest@localhost:5672\" export RUSTUS_HOOKS_AMQP_EXCHANGE = \"celery\" export RUSTUS_HOOKS_AMQP_EXCHANGE_KIND = \"direct\" export RUSTUS_HOOKS_AMQP_ROUTING_KEY = \"celery\" export RUSTUS_HOOKS_AMQP_CELERY = \"yes\" rustus","title":"Using Rustus with Celery"}]}